//          Copyright Tom Westerhout 2018.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

/// \rst
///
/// \endrst

#include <iostream>
#include <boost/static_views/static_map.hpp>

struct equal_c {
    template <class Char>
    constexpr auto operator()(Char const* const a, Char const* const b) const
        noexcept -> bool
    {
        if (a == nullptr || b == nullptr) { return a == b; }
        std::size_t i = 0;
        while (a[i] != Char{} && a[i] == b[i]) {
            ++i;
        }
        return a[i] == Char{} && b[i] == Char{};
    }
};

// First, an easy example

// clang-format off
enum class weekday {
    sunday,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday,
    saturday
};
// clang-format on

// This enum is easy because values are just subsequent integers. We can thus
// use a simple look-up table:

// clang-format off
static constexpr char const* weekday_strings[] = {
    "sunday",
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday"
};
// clang-format on

// The "old" way of implementing enum -> string conversion.
//
// We mark the function `extern "C"` so that it has the same name in
// the object file. This means, however, that we can't throw exceptions on
// invalid input, so we return a null pointer instead.
extern "C"
BOOST_STATIC_VIEWS_NOINLINE
constexpr auto weekday_to_string_old(weekday const x) noexcept
    -> char const*
{
    auto constexpr size =
        std::end(weekday_strings) - std::begin(weekday_strings);
    auto const i = static_cast<std::underlying_type_t<weekday>>(x);
    if (i >= size) { return nullptr; }
    return weekday_strings[i];
}

// Alternatively, we can explicitly construct a mapping of weekdays to strings.

// clang-format off
static constexpr std::pair<weekday, char const*> weekday_to_string[] = {
    {weekday::sunday, "sunday"},
    {weekday::monday, "monday"},
    {weekday::tuesday, "tuesday"},
    {weekday::wednesday, "wednesday"},
    {weekday::thursday, "thursday"},
    {weekday::friday, "friday"},
    {weekday::saturday, "saturday"}
};
// clang-format on

// We need a hash function. Here, let's just overload the default hash function
// for our type.
BOOST_STATIC_VIEWS_BEGIN_NAMESPACE

template <>
struct hash_impl<weekday> {
    constexpr auto operator()(weekday const x) const noexcept -> std::size_t
    {
        return static_cast<std::size_t>(x);
    }
};

BOOST_STATIC_VIEWS_END_NAMESPACE

// The newer, longer, and slower version of the to_string :)
//
extern "C" constexpr auto weekday_to_string_new(weekday const x) noexcept
    -> char const*
{
    using value_type = std::pair<weekday, char const*>;
#if 0
    auto constexpr size =
        std::end(weekday_strings) - std::begin(weekday_strings);
#else
    // It is faster to divide by a power of 2, and seeing as we don't have too
    // much data we can afford the overhead of an extra couple of bytes.
    auto constexpr size = 8;
#endif
    constexpr auto weekday_map =
        boost::static_views::make_static_map_impl<size, 1>{}(
            boost::static_views::raw_view(weekday_to_string),
            &value_type::first, &value_type::second);
    auto* s = weekday_map.find(x);
    return (s == nullptr) ? nullptr : s->second;
}

// And some simple checks that our functions actually work.
void weekday_test()
{
    static_assert(
        equal_c{}(weekday_to_string_old(weekday::tuesday), "tuesday"), "");
    static_assert(
        equal_c{}(weekday_to_string_old(weekday::friday), "friday"), "");
    static_assert(
        weekday_to_string_old(static_cast<weekday>(128)) == nullptr, "");
    static_assert(
        equal_c{}(weekday_to_string_new(weekday::wednesday), "wednesday"), "");
    static_assert(
        equal_c{}(weekday_to_string_new(weekday::sunday), "sunday"), "");
    static_assert(
        weekday_to_string_new(static_cast<weekday>(128)) == nullptr, "");

    // These two don't appear in assembly, i.e. compiler is able to perform the
    // look-up at compile-time if the argument is a compile-time expression.
    if (!equal_c{}(weekday_to_string_old(weekday::thursday), "thursday"))
        std::terminate();
    if (!equal_c{}(weekday_to_string_new(weekday::thursday), "thursday"))
        std::terminate();
}

// As for performance, here are the asm listings of to_string_old and new
// generated by Clang-7
//
// 0000000000000080 <to_string_old>:
//   80:   83 ff 06                cmp    $0x6,%edi
//   83:   7e 03                   jle    88 <to_string_old+0x8>
//   85:   31 c0                   xor    %eax,%eax
//   87:   c3                      retq
//   88:   48 63 c7                movslq %edi,%rax
//   8b:   48 8d 0d 00 00 00 00    lea    0x0(%rip),%rcx        # 92 <to_string_old+0x12>
//   92:   48 8b 04 c1             mov    (%rcx,%rax,8),%rax
//   96:   c3                      retq
//   97:   66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
//   9e:   00 00
//
// 00000000000000a0 <to_string_new>:
//   a0:   89 f8                   mov    %edi,%eax
//   a2:   48 8d 0d 00 00 00 00    lea    0x0(%rip),%rcx        # a9 <to_string_new+0x9>
//   a9:   48 63 44 81 08          movslq 0x8(%rcx,%rax,4),%rax
//   ae:   48 83 f8 07             cmp    $0x7,%rax
//   b2:   75 03                   jne    b7 <to_string_new+0x17>
//   b4:   31 c0                   xor    %eax,%eax
//   b6:   c3                      retq
//   b7:   48 c1 e0 04             shl    $0x4,%rax
//   bb:   48 8d 0d 00 00 00 00    lea    0x0(%rip),%rcx        # c2 <to_string_new+0x22>
//   c2:   39 3c 08                cmp    %edi,(%rax,%rcx,1)
//   c5:   75 06                   jne    cd <to_string_new+0x2d>
//   c7:   48 8b 44 08 08          mov    0x8(%rax,%rcx,1),%rax
//   cc:   c3                      retq
//   cd:   31 c0                   xor    %eax,%eax
//   cf:   c3                      retq
//
// The old version is, obviously, better, but it's cool that Static_views'
// version is only a few instructions longer.


// Now, how about the case when values are not distributed nicely?
// Consider the following, for example:

// clang-format off
enum class colour : std::uint32_t {
    coral = 0xFF7F50,
    crimson = 0xDC143C,
    cyan = 0x00FFFF,
    firebrick = 0xB22222,
    gold = 0xFFD700,
    gray = 0x7F7F7F,
    green = 0x008000,
    indigo = 0x4B0082,
    magenta = 0xFF00FF,
    olive = 0x808000,
    orange = 0xFFA500,
    pink = 0xFFC0CB,
    thistle = 0xD8BFD8,
    yellow = 0xFFFF00,
};
// clang-format on

// Now, we can't use a simple look-up table, and the "old" version becomes a
// switch:
extern "C" constexpr auto colour_to_string_old(colour const x) noexcept
    -> char const*
{
    switch (x) {
    case colour::coral: return "coral";
    case colour::crimson: return "crimson";
    case colour::cyan: return "cyan";
    case colour::firebrick: return "firebrick";
    case colour::gold: return "gold";
    case colour::gray: return "gray";
    case colour::green: return "green";
    case colour::indigo: return "indigo";
    case colour::magenta: return "magenta";
    case colour::olive: return "olive";
    case colour::orange: return "orange";
    case colour::pink: return "pink";
    case colour::thistle: return "thistle";
    case colour::yellow: return "yellow";
    default: return nullptr;
    } // end switch
}

// clang-format off
static constexpr std::pair<colour, char const*> colour_to_string[] = {
    {colour::coral, "coral"},
    {colour::crimson, "crimson"},
    {colour::cyan, "cyan"},
    {colour::firebrick, "firebrick"},
    {colour::gold, "gold"},
    {colour::gray, "gray"},
    {colour::green, "green"},
    {colour::indigo, "indigo"},
    {colour::magenta, "magenta"},
    {colour::olive, "olive"},
    {colour::orange, "orange"},
    {colour::pink, "pink"},
    {colour::thistle, "thistle"},
    {colour::yellow, "yellow"},
};
// clang-format on

BOOST_STATIC_VIEWS_BEGIN_NAMESPACE

template <>
struct hash_impl<colour> {
    constexpr auto operator()(colour const x) const noexcept -> std::size_t
    {
        return static_cast<std::size_t>(x);
    }
};

BOOST_STATIC_VIEWS_END_NAMESPACE

extern "C" constexpr auto colour_to_string_new(colour const x) noexcept
    -> char const*
{
    using value_type = std::pair<colour, char const*>;
    auto constexpr size =
        std::end(colour_to_string) - std::begin(colour_to_string);
    constexpr auto colour_map =
        boost::static_views::make_static_map_impl<2 * size, 3>{}(
            boost::static_views::raw_view(colour_to_string),
            &value_type::first, &value_type::second);
    auto* s = colour_map.find(x);
    return (s == nullptr) ? nullptr : s->second;
}

void colour_test()
{
    static_assert(equal_c{}(colour_to_string_old(colour::cyan), "cyan"), "");
    static_assert(
        equal_c{}(colour_to_string_old(colour::orange), "orange"), "");
    static_assert(
        colour_to_string_old(static_cast<colour>(0xFF000000)) == nullptr, "");
    static_assert(equal_c{}(colour_to_string_new(colour::pink), "pink"), "");
    static_assert(equal_c{}(colour_to_string_new(colour::green), "green"), "");
    static_assert(
        colour_to_string_new(static_cast<colour>(0xFF000000)) == nullptr, "");

    // These two don't appear in assembly, i.e. compiler is able to perform the
    // look-up at compile-time if the argument is a compile-time expression.
    if (!equal_c{}(colour_to_string_old(colour::gray), "gray"))
        std::terminate();
    if (!equal_c{}(colour_to_string_new(colour::gray), "gray"))
        std::terminate();
}

// Force the compiler to emit code for our functions.
BOOST_STATIC_VIEWS_UNUSED auto* _tmp_ptr_1 = &weekday_to_string_old;
BOOST_STATIC_VIEWS_UNUSED auto* _tmp_ptr_2 = &weekday_to_string_new;
BOOST_STATIC_VIEWS_UNUSED auto* _tmp_ptr_3 = &colour_to_string_old;
BOOST_STATIC_VIEWS_UNUSED auto* _tmp_ptr_4 = &colour_to_string_new;

int main(int argc, char** argv)
{
    weekday_test();
    colour_test();
    return 0;
}

