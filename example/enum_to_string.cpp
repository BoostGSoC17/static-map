//          Copyright Tom Westerhout 2018.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

/// \rst
///
/// \endrst

#include <iostream>
#include <boost/static_views/static_map.hpp>

struct equal_c {
    template <class Char>
    constexpr auto operator()(Char const* const a, Char const* const b) const
        noexcept -> bool
    {
        if (a == nullptr || b == nullptr) { return a == b; }
        std::size_t i = 0;
        while (a[i] != Char{} && a[i] == b[i]) {
            ++i;
        }
        return a[i] == Char{} && b[i] == Char{};
    }
};

// First, an easy example

// clang-format off
enum class weekday {
    sunday,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday,
    saturday
};
// clang-format on

// This enum is easy because values are just subsequent integers. We can thus
// use a simple look-up table:

// clang-format off
static constexpr char const* weekday_strings[] = {
    "sunday",
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday"
};
// clang-format on

// The "old" way of implementing enum -> string conversion.
//
// We mark the function `extern "C"` so that it has the same name in
// the object file. This means, however, that we can't throw exceptions on
// invalid input, so we return a null pointer instead.
extern "C" constexpr auto to_string_old(weekday const x) noexcept -> char const*
{
    auto constexpr size =
        std::end(weekday_strings) - std::begin(weekday_strings);
    auto const i = static_cast<std::underlying_type_t<weekday>>(x);
    if (i >= size) { return nullptr; }
    return weekday_strings[i];
}

// Alternatively, we can explicitly construct a mapping of weekdays to strings.

// clang-format off
static constexpr std::pair<weekday, char const*> weekday_to_string[] = {
    {weekday::sunday, "sunday"},
    {weekday::monday, "monday"},
    {weekday::tuesday, "tuesday"},
    {weekday::wednesday, "wednesday"},
    {weekday::thursday, "thursday"},
    {weekday::friday, "friday"},
    {weekday::saturday, "saturday"}
};
// clang-format on

// We need a hash function. Here, let's just overload the default hash function
// for our type.
BOOST_STATIC_VIEWS_BEGIN_NAMESPACE

template <>
struct hash_impl<weekday> {
    constexpr auto operator()(weekday const x) const noexcept -> std::size_t
    {
        return static_cast<std::size_t>(x);
    }
};

BOOST_STATIC_VIEWS_END_NAMESPACE

// The newer, longer, and slower version of the to_string :)
//
extern "C" constexpr auto to_string_new(weekday const x) noexcept -> char const*
{
    using value_type = std::pair<weekday, char const*>;
#if 0
    auto constexpr size =
        std::end(weekday_strings) - std::begin(weekday_strings);
#else
    // It is faster to divide by a power of 2, and seeing as we don't have too
    // much data we can afford the overhead of an extra couple of bytes.
    auto constexpr size = 8;
#endif
    constexpr auto weekday_map =
        boost::static_views::make_static_map_impl<size, 1>{}(
            boost::static_views::raw_view(weekday_to_string),
            &value_type::first, &value_type::second);
    auto* s = weekday_map.find(x);
    return (s == nullptr) ? nullptr : s->second;
}

// And some simple checks that our functions actually work.
void test()
{
    static_assert(equal_c{}(to_string_old(weekday::tuesday), "tuesday"), "");
    static_assert(equal_c{}(to_string_old(weekday::friday), "friday"), "");
    static_assert(to_string_old(static_cast<weekday>(128)) == nullptr, "");
    static_assert(
        equal_c{}(to_string_new(weekday::wednesday), "wednesday"), "");
    static_assert(equal_c{}(to_string_new(weekday::sunday), "sunday"), "");
    static_assert(to_string_new(static_cast<weekday>(128)) == nullptr, "");

    // These two don't appear in assembly, i.e. compiler is able to perform the
    // look-up at compile-time if the argument is a compile-time expression.
    if (!equal_c{}(to_string_old(weekday::thursday), "thursday"))
        std::terminate();
    if (!equal_c{}(to_string_new(weekday::thursday), "thursday"))
        std::terminate();
}

// As for performance, here are the asm listings of to_string_old and new
// generated by Clang-7
//
// 0000000000000080 <to_string_old>:
//   80:   83 ff 06                cmp    $0x6,%edi
//   83:   7e 03                   jle    88 <to_string_old+0x8>
//   85:   31 c0                   xor    %eax,%eax
//   87:   c3                      retq
//   88:   48 63 c7                movslq %edi,%rax
//   8b:   48 8d 0d 00 00 00 00    lea    0x0(%rip),%rcx        # 92 <to_string_old+0x12>
//   92:   48 8b 04 c1             mov    (%rcx,%rax,8),%rax
//   96:   c3                      retq
//   97:   66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1)
//   9e:   00 00
//
// 00000000000000a0 <to_string_new>:
//   a0:   89 f8                   mov    %edi,%eax
//   a2:   48 8d 0d 00 00 00 00    lea    0x0(%rip),%rcx        # a9 <to_string_new+0x9>
//   a9:   48 63 44 81 08          movslq 0x8(%rcx,%rax,4),%rax
//   ae:   48 83 f8 07             cmp    $0x7,%rax
//   b2:   75 03                   jne    b7 <to_string_new+0x17>
//   b4:   31 c0                   xor    %eax,%eax
//   b6:   c3                      retq
//   b7:   48 c1 e0 04             shl    $0x4,%rax
//   bb:   48 8d 0d 00 00 00 00    lea    0x0(%rip),%rcx        # c2 <to_string_new+0x22>
//   c2:   39 3c 08                cmp    %edi,(%rax,%rcx,1)
//   c5:   75 06                   jne    cd <to_string_new+0x2d>
//   c7:   48 8b 44 08 08          mov    0x8(%rax,%rcx,1),%rax
//   cc:   c3                      retq
//   cd:   31 c0                   xor    %eax,%eax
//   cf:   c3                      retq
//
// The old version is, obviously, better, but it's cool that Static_views'
// version is only a few instructions longer.

int main(int argc, char** argv)
{
    test();
    return 0;
}

